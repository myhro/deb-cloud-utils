#!/bin/bash
# vi: ts=4 noexpandtab
#
# TODO:
# - move all of this into uec-run-instances (will need support for multiple
#  instances then)
# - add some mechanism to just run and wait until "not pending"
# - add run-command support
# - add --terminate flag (run-command-and-terminate support)
# - add --ssh-user flag (default hard coded value is 'ubuntu'
# - add better ssh key identification options:
#   - [probably default] scrape/verify in console output
#   - trust (no verify)
#   - allow user data to be passed
#     if insertion via user-data, then use multipart mime for both
#     this would be ubuntu specific

TEMP_D=""
SSH_USER="ubuntu"
IID=""
EC2PRE=${EC2PRE:-euca-}
VERBOSITY=0

error() { echo "$@" 1>&2; }
errorp() { printf "$@" 1>&2; }
fail() { 
	[ $# -eq 0 ] || error "$@";
	if [ -n "${IID}" ]; then
		error "terminating ${IID}"
		error "==== console log begin ===="
		${EC2PRE}get-console-output "${IID}" 1>&2
		error "==== console log end   ===="
		${EC2PRE}terminate-instances "${IID}"
	fi
	exit 1;
}
failp() { [ $# -eq 0 ] || errorp "$@"; fail; }
debug() {
	local level=${1}
	shift;
	[ "${level}" -gt "${VERBOSITY}" ] && return
	error "$(date):" "${@}"
}
cleanup() {
	[ -z "${TEMP_D}" ] || rm -Rf "${TEMP_D}"
}
sigint() { error "caught user interupt"; fail; }
sshconnect() {
	local errlog=${1} out=""; shift;
	out=$(ssh "$@" "/bin/sh -c 'echo true'" 2>"${errlog}" )
	[ "${out}" = "true" ]
}

Usage() {
	cat <<EOF
Usage: ${0##*/} [ options ] ami-id

   Run instance of 'ami-id'. Wait for it to come up
   and verify ssh connection before returning

   Will exit failure if instance seems not to have come up.
   It should not exit failure without killing instance.

   options:
   -h|--help                  print this help
      --instance-type x       start instance of instance-type x
      --key           x       start instance with --key x
      --ssh-pubkey    f       public key to insert into image
      --ssh-privkey   f       private key to connect with (ssh -i)
                              defaults to pubkey without .pub if pubkey given
                              and that file exists
      --associate-ip  i       associate elastic IP i with instance
      --known-hosts   f       write ssh fingerprint to ssh known hosts
                              file f, removing old entries for this host
EOF
}

bad_Usage() { Usage 1>&2; [ $# -eq 0 ] || error "$@"; exit 1; }

di_field() {
	local field=$1 f=""
	local fields=( itype iid ami host host_int state )
	for((i=0;i<${#fields[@]};i++)); do
		[ "${fields[$i]}" = "${field}" ] && { f=$(($i+1)) ; break; }
	done
	[ -n "$f" ] || return 1
	local cmd='$1 == "INSTANCE" { print $'$f' }'
	_RET=$(awk '-F\t' "$cmd")
}

write_ud_script() {
	local out_sshd_pub=$1 out_script=$2 user_pubkey=$3
	local ssh_user=${SSH_USER:-ubuntu} 
	ssh-keygen -q -C "root@cloudhost" \
		-f "${TEMP_D}/ssh_host_rsa_key" -t rsa -N "" ||
		{ error "failed to gen ssh key"; return 1; }
	{
	cat <<EOF
#!/bin/sh

echo ============ \$(date) =============
echo ############ populating keys ##############
(
umask 066
cat >/etc/ssh/ssh_host_rsa_key <<END
$(cat "${TEMP_D}/ssh_host_rsa_key")
END
)

cat >/etc/ssh/ssh_host_rsa_key.pub <<END
$(cat "${TEMP_D}/ssh_host_rsa_key.pub")
END
ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub
EOF
	if [ -n "${user_pubkey}" -a "${user_pubkey}" != "none" ]; then
		# apparently there is a problem with invoking commands like this on
		# older kernels (including hardy).  After some debugging, you'll
		# get errors like:
		#    sudo: Please use single character options
		# http://archives.neohapsis.com/archives/openbsd/2002-01/0980.html
		cat <<END_CAT
sudo -Hu "${ssh_user}" sh <<"END_SH"
d=\$HOME/.ssh; mkdir -p "\$d" 2>/dev/null && chmod 700 "\$d" &&
cat >> "\${d}/authorized_keys" <<"END_KEY"
$(cat "${user_pubkey}")
END_KEY
END_SH
END_CAT
	fi
true
	} > "${out_script}"
	[ $? -eq 0 ] || { error "failed to write to ${out_script}"; return 1; }

	cat "${TEMP_D}/ssh_host_rsa_key.pub" > "${out_sshd_pub}" ||
		{ error "failed to write to ${out_sshd_pub}"; return 1; }
}

short_opts="hv"
long_opts="associate-ip:,help,instance-type:,key:,known-hosts:,ssh-privkey:,ssh-pubkey:,verbose"
getopt_out=$(getopt --name "${0##*/}" \
	--options "${short_opts}" --long "${long_opts}" -- "$@") &&
	eval set -- "${getopt_out}" ||
	bad_Usage

ami=""
host=""
sleeptime=10
instance_type=""
ssh_wait_max=300
ssh_pubkey=""
ssh_privkey=""
associate_ip=""
known_hosts="${HOME}/.ssh/known_hosts"
pt=( )

while [ $# -ne 0 ]; do
	cur=${1}; next=${2};
	case "$cur" in
		-h|--help) Usage; exit 0;;
		-v|--verbose)
			VERBOSITY=$((${VERBOSITY}+1));;
		   --instance-type)
			pt[${#pt[@]}]="$cur"; pt[${#pt[@]}]="$next"
			instance_type=${next}; shift;;
		   --key)
			pt[${#pt[@]}]="$cur"; pt[${#pt[@]}]="$next";;
		   --ssh-pubkey)
			ssh_pubkey="${next}"; shift;;
		   --ssh-privkey)
			ssh_privkey="${next}"; shift;;
		   --associate-ip)
		    associate_ip="${next}"; shift;;
		   --known-hosts)
			known_hosts="${next}"; shift;;
		--) shift; break;;
	esac
	shift;
done

[ $# -eq 1 -o $# -eq 2 ] || bad_Usage "must provide ami"
ami=${1}

START_TIME=$SECONDS
TEMP_D=$(mktemp -d ${TMPDIR:-/tmp}/${0##*/}.XXXXXX) ||
	fail "failed to make tmp dir"
trap cleanup EXIT
trap sigint SIGINT

out_inst_run="${TEMP_D}/instance-run.out"
out_inst_desc="${TEMP_D}/instance-describe.out"
out_keyscan="${TEMP_D}/keyscan.out"
out_userdata="${TEMP_D}/user-data.script"
out_sshd_pub="${TEMP_D}/sshd_pub.txt"
out_associate_ip="${TEMP_D}/out_associate_ip.txt"
out_clean_knownhosts="${TEMP_D}/out_clean_knownhosts.txt"
out_ami_info="${TEMP_D}/ami.txt"
out_ssh_err="${TEMP_D}/ssh_err.txt"

if [ -z "${ssh_pubkey}" ]; then
	def_pubk="${HOME}/.ssh/id_rsa.pub"
	if [ -f "${def_pubk}" ]; then 
		ssh_pubkey="${def_pubk}"
	else
		fail "unable to find a public key. use --ssh-pubkey=none for none"
	fi
fi

write_ud_script "${out_sshd_pub}" "${out_userdata}" \
	${ssh_pubkey:+"${ssh_pubkey}"} ||
	fail "failed to write user data script"

if [ -z "${instance_type}" ]; then
	${EC2PRE}describe-images "${ami}" > "${out_ami_info}" &&
		arch=$(awk '-F\t' '$1 == "IMAGE" {print $8}' "${out_ami_info}") &&
		[ -n "${arch}" ] ||
		fail "unable to determine arch of ${ami}"
	case "${arch}" in
		i386) instance_type="m1.small";;
		amd64|x86_64) instance_type="m1.large";;
		*) fail "no default instance-type for ${arch}. pass --instance-type";;
	esac
	debug 2 "using instance-type=${instance_type}"
fi


debug 1 "${EC2PRE}run-instances ${pt[@]} --instance-type ${instance_type} ${ami}"
${EC2PRE}run-instances "${pt[@]}" --instance-type "${instance_type}" \
	"--user-data-file=${out_userdata}" "$ami" > "${out_inst_run}" ||
	fail "failed to run instance"
start=${SECONDS}

di_field iid < "${out_inst_run}" && iid=${_RET} && [ -n "${iid}" ] ||
	fail "reading iid from run-instances output failed"

# IID read by fail code
IID="${iid}"

debug 1 "instance id is ${iid}"

if [ -n "${associate_ip}" ]; then
	n=0
	while ! ${EC2PRE}associate-address \
		-i "${iid}" "${associate_ip}" \
		> "${out_associate_ip}" 2>&1 &&
		[ $n -lt 5 ]; do
		debug 2 "associate-ip -i ${iid} ${associate_ip} failed, trying again"
		sleep 3
		n=$((n+1))
	done
	[ ${n} -eq 5 ] && {
		cat "${out_associate_ip}" 1>&2;
		fail "failed to associate ip ${associate_ip}";
	}
	debug 1 "associated ip ${associate_ip} to ${iid}"
fi

while sleep ${sleeptime}; do
	${EC2PRE}describe-instances "${iid}" > "${out_inst_desc}" &&
		di_field state < "${out_inst_desc}" ||
		fail "describe-instances ${iid} failed"
	state=${_RET}
	case ${state} in
		pending) :;;
		terminated) fail "${iid} went to terminated";;
		running) break;;
		*) fail "${iid} in unknown state: ${state}";;
	esac
	debug 2 "${iid} in ${state} ($((${SECONDS}-${start})) seconds)"
done

di_field host < "${out_inst_desc}" && [ -n "${_RET}" ] &&
	host=${_RET} || fail "host running, but no hostname!"

debug 1 "instance as ${host} running after $((${SECONDS}-${start}))s"

# here you could/should wait, and scrape console for keys
# right now, all this does is keyscan and compare with expected
# where expected is the fingerprint of the key we generated
waited=0
ssh_start=${SECONDS}
expected=$(awk '{print $2}' "${out_sshd_pub}")
while : ; do
	ssh-keyscan -t rsa "${host}" > "${out_keyscan}" 2>"${out_keyscan}.err"
	found=$(awk '{print $3}' "${out_keyscan}")
	[ -n "${found}" -a "${found}" = "${expected}" ] && break
	waited=$((${SECONDS}-${ssh_start}))
	[ $waited -lt $ssh_wait_max ] ||
		fail "waited to long for ssh to get assigned key ($waited seconds)"
	debug 2 "sleeping 10. $((${SECONDS}-${ssh_start}))/${ssh_wait_max} waited for ssh-keyscan"
	sleep 10
done

ssh_start=${SECONDS}
ssh_args=()
ssh_args[${#ssh_args[@]}]=-o &&
ssh_args[${#ssh_args[@]}]="UserKnownHostsFile=${known_hosts}"

if [ -n "${ssh_privkey}" -a "${ssh_privkey}" != "none" ]; then
	ssh_args=( "${ssh_args[@]}" -i "${ssh_privkey}" )
elif [ -z "${ssh_privkey}" -a -n "${ssh_pubkey}" ] &&
     [ "${ssh_pubkey}" != "none" -a -f "${ssh_pubkey%.pub}" ]; then
	ssh_privkey="${ssh_pubkey%.pub}"
	ssh_args=( "${ssh_args[@]}" -i "${ssh_privkey}" )
fi

if [ -n "${known_hosts}" ]; then
	if [ -f "${known_hosts}" ]; then
		{
			{ [ -z "${associate_ip}" ] ||
			  ssh-keygen -R "${associate_ip}" -f "${known_hosts}"; } &&
			ssh-keygen -R "${host}" -f "${known_hosts}"
		} > "${out_clean_knownhosts}" 2>&1 ||
		{
			cat "${out_clean_knownhosts}";
			fail "failed to remove ${host}/${associate_ip} from ${known_hosts}"
		}
	fi
	cat "${out_keyscan}" >> "${known_hosts}" ||
		fail "failed to write to ${known_hosts}"
fi

ssh_args=( "${ssh_args[@]}" -o ConnectTimeout=5 -o Batchmode=yes 
	-o StrictHostKeyChecking=yes )

debug 2 "sshconnect with ${ssh_args[@]} ${SSH_USER}@${host}"
while ! sshconnect "${out_ssh_err}" "${ssh_args[@]}" "${SSH_USER}@${host}"; do
	waited=$((${SECONDS}-${ssh_start}))
	[ $waited -lt $ssh_wait_max ] || {
		cat "${out_ssh_err}" 1>&2
		fail "waited to long for ssh ($waited seconds)";
	}
	[ ${VERBOSITY} -le 1 ] || cat "${out_ssh_err}" 1>&2
	debug 2 "sleeping 10. $((${SECONDS}-${ssh_start}))/${ssh_wait_max} waited for ssh-connect"
	sleep 10
done

debug 2 "ssh verified, total time $((${SECONDS}-${START_TIME}))s"

printf "%s\t%s\n" "${iid}" "${host}"
exit 0
