#!/usr/bin/python
# -*- coding: utf-8 -*-

# vi: ts=4 noexpandtab

## Copyright (C) 2011 Ben Howard <ben.howard@canonical.com>
## Date: 25 February 2012
##
## This comes with ABSOLUTELY NO WARRANTY; for details see COPYING.
## This is free software, and you are welcome to redistribute it
## under certain conditions; see copying for details.

from syncimgs.build_json import CloudJSON
from datetime import datetime, time, date
import syncimgs.build_json
import argparse
import logging
import sys
import json
import re

logging.basicConfig(format='%(asctime)s %(levelname)s %(message)s')
logger = logging.getLogger('_sync-image_')
logger.setLevel(logging.CRITICAL)


def formatting_help():
    print """
The following are valid format values for displaying Query2 data for clouds

    %(region)s - region name
    %(id)s - the cloud vendor ID
    %(instance_type)s - instance type
    %(cloud)s - cloud vendor name, i.e "ec2"
    %(ramdisk_id)s - ramdisk ID, largely obsolete
    %(registered_name)s - registered name in cloud system
    %(build_serial)s - the build serial ID
    %(path)s - Download URL for corresponding instance
    %(sha1)s - SHA1 of the file
    %(arch)s - architecture of the image

The following are valid format values when running with "--builds":

    %(path)s - the path of the file
    %(sha1)s - the SHA1 checksum of the file
    %(sha512)s - the SHA512 checksum of the file
    %(description) - description of the file

Example:
    ubuntu-cloudimg-query2 --format "%(build_serials) %(id)s" us-west-2 ec2
        Show the build serial and the ids of the images for us-west-2
        region of EC2

    ubuntu-cloudimg-query2 --builds --format "%(path)s" precise armhf
        Show the files for Precise

"""


if __name__ == '__main__':

    parser = argparse.ArgumentParser(prog='Ubuntu Cloud Image Query2')
    parser.add_argument('--url', action='store',
                        default='https://cloud-images.ubuntu.com/query2'
                        , help='Base URL to fetch from')
    parser.add_argument('--no-bz2', dest='bz2', action='store_true',
                        default=True,
                        help='Use uncompressed query2 JSON')
    parser.add_argument('--cloud', action='store', default='EC2',
                        help='Cloud name to fetch from, i.e. EC2')
    parser.add_argument('--no-gpg', action='store_false', dest='gpg',
                        default=True,
                        help='Do not validate GPG signature')
    parser.add_argument('--verbose', action='store_true',
                        default=False,
                        help="Be verbose about what's happening")
    parser.add_argument('--builds', action='store_true', default=False,
                        help='Get build information, not AMI inforamtion'
                        )
    parser.add_argument('--format', action='store', default=None,
                        help='Default query parameters, see --show_format'
                        )
    parser.add_argument('--show-format', action='store_true', default=False,
                        help='Show formating options')
    parser.add_argument('--gpg-home', action="store",
                        default="/usr/share/cloud-utils/dot-gpg",
                        help="Default GPG home for validating GPG signatures"
                       )
    parser.add_argument('--all', action="store_true", default=False,
                        help="Show all regions for a clouds")
    parser.add_argument('--all-builds', action="store_true", default=False,
                        help="Show all builds")
    parser.add_argument('--serial', action="store", default=None,
                        help="Query build files for a specific serial")
    parser.add_argument('--included', action="append",
                        help="Files to include when querying builds")
    parser.add_argument('--excluded', action="append",
                        help="Files to exclude when querying builds")

    parser.add_argument('args', nargs=argparse.REMAINDER)

    opts = parser.parse_args()

    if not opts.included:
        opts.included = []

    if not opts.excluded:
        opts.excluded = []

    if not opts.format:
        opts.format = '%(id)s'

    if opts.show_format:
        formatting_help()
        sys.exit(0)

    v = {}
    region_re = re.compile('.*-.*-\d')
    type_re = re.compile('(instance-store)|(ebs)|(hvm)')
    arch_re = re.compile('(amd64)|(i386)|(armel)|(armhf)')
    file_re = \
        re.compile('(root.tar.gz)|(tar.gz)|(qcow2)|(manifest)|(vmdk)|(kernel)|(ovf)'
                   )
    release_re = re.compile('(release)|(rel*)')
    daily_re = re.compile('(daily)')
    cloud_re = re.compile('(ec2)|(azure)|(openstack)|(maas)')
    base_re = re.compile('(server)|(desktop)')
    distro_re = \
        re.compile('(hardy)|(lucid)|(maverick)|(natty)|(oneiric)|(precise)|(quantal)'
                   )

    for val in opts.args:
        val = val.lower()
        key = None

        if region_re.match(val):
            key = 'region'
        elif type_re.match(val):

            key = 'instance_type'
        elif daily_re.match(val):

            key = 'release_tag'
            val = 'daily'
        elif release_re.match(val):

            key = 'release_tag'
            val = 'release'
        elif base_re.match(val):

            key = 'stream'
        elif cloud_re.match(val):

            key = 'cloud'
        elif arch_re.match(val):

            key = 'arch'
        elif distro_re.match(val):

            key = 'distro'
        elif file_re.match(val):

            key = 'file_type'

        if key not in v.keys():
            v[key] = val
        else:
            raise Exception('You cannot specify %s and %s at the same time'
                             % (v[key], val))

    if 'cloud' not in v.keys():
        v['cloud'] = 'ec2'

    if 'arch' not in v.keys():
        v['arch'] = 'amd64'

    if 'region' not in v.keys() and v['cloud'] == 'ec2':
        v['region'] = 'us-east-1'

    if 'instance_type' not in v.keys():
        v['instance_type'] = 'ebs'

    if 'release_tag' not in v.keys():
        v['release_tag'] = 'release'

    if 'distro' not in v.keys():
        v['distro'] = 'precise'

    if 'stream' not in v.keys():
        v['stream'] = 'server'

    if 'file_type' not in v.keys():
        v['file_type'] = 'root.tar.gz'

    if opts.verbose:
        logger.setLevel(logging.DEBUG)

    url = '%s/%s/%s/%s.json' % (opts.url, v['stream'], v['distro'],
                                opts.cloud.lower())

    if opts.builds:
        url = url.replace(opts.cloud.lower(), 'builds')

    if opts.bz2:
        url = '%s.bz2' % url

    if opts.verbose:
        logger.debug('Configuration of query:\n%s' % json.dumps(v,
                     indent=4))
        logger.debug('Calling catalog.get_single with:')
        logger.debug('catalog.get_single(%s, %s, %s, %s, %s, %s, %s)'
                     % (
            v['distro'],
            v['stream'],
            v['release_tag'],
            v['instance_type'],
            v['arch'],
            v['cloud'],
            v['region'],
            ))

    cloudjson = CloudJSON(
                    gpg_verify=opts.gpg,
                    url=url,
                    gpg_home=opts.gpg_home
                    )
    catalog = cloudjson.build_catalog

    if not opts.builds:

        r = catalog.get_reg(
            v['distro'],
            v['stream'],
            v['release_tag'],
            v['instance_type'],
            v['arch'],
            v['cloud'],
            v['region'],
            output=opts.format,
            all_regions=opts.all
            )

        if r:
            print r
            sys.exit(0)

    else:

        r = catalog.fetch_files(
            v['distro'],
            v['stream'],
            v['release_tag'],
            v['arch'],
            opts.included,
            opts.excluded,
            serial=opts.serial,
            all=opts.all,
            )

        if r:
            print r
            sys.exit(0)

    sys.stderr.write('Query returned no results\n')
    sys.exit(1)
